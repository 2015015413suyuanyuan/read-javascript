# read-javascript  

# 你不知道的JavaScript （上卷）

## 第一章  作用域是什么  

### 1.1 编译原理

分词/词法分析 解析/语法分析 代码生成

### 1.2 理解作用域

1. 引擎

从头到尾负责整个JavaScript程序的编译及执行过程。

2. 编译器

引擎的好朋友之一，负责语法分析及代码生成

3. 作用域

负责收集并维护由所有生命的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

LHS查询：试图找到变量的容器本身

RHS查询：查找某个变量的值

### 1.4 异常

如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError（reference 引用 参考）异常。

如果RHS查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者null或undefined类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError。

ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

### 1.5 小结

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。

不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作者为标识符，或者抛出ReferenceError异常（严格模式下）。

## 第二章 词法作用域

**简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时变量和作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。**

### 2.1 词法阶段

查找

作用域查找会在找到第一个匹配的标识符时停止。在多次的嵌套作用域中可以定义同名的标识符，这叫作‘遮蔽效应’（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

全局变量会自动成为全局对象（比如浏览器中的window对象）的属性，因此可以不直接通过全局对象的次发名称，而是间接地通过对全局对象属性的引用来对其进行访问。  window.a   通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽，无论如何都无法被访问到。

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。

词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz， 词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接 管对 bar 和 baz 属性的访问。

### 2.2 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来‘修改’（也可以说欺骗）词法作用域呢？

#### 2.2.1 eval

JavaScript中的eval()函数可以接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。
```
function foo(str, a) {     eval( str ); // 欺骗！     console.log( a, b ); } 
 
var b = 2; 
 
foo( "var b = 3;", 1 ); // 1, 3

```



