## 检测类型

### typeof操作符  instanceof操作符

**typeof操作符：确定一个变量是字符串、数值、布尔值还是undefined**的最佳工具。

**如果变量的值是一个对象或null**，则typeof操作符会返回“**object**”。

**instanceof操作符：判断某个值是什么类型的对象。**

其语法如下所示：
>>  result = variable instanceof constructor

### 4.2 执行环境及作用域 
**执行环境**（execution context，为简单起见，有时也称为“环境”）是 JavaScript中最为重要的一个概 念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个 与之关联的**变量对象**（variable object），环境中定义的所有**变量和函数**都保存在这个对象中。

虽然我们 编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 **全局执行环境**是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环 境的对象也不一样。在 Web 浏览器中，**全局执行环境被认为是 window 对象**，因 此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁）。 

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个**环境栈**中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流 正是由这个方便的机制控制着。 

当代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对 象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中 的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。 请看下面的示例代码： 
 ```
var color = "blue"; 
 
function changeColor(){     
if (color === "blue")
    {    
        color = "red";     
    } 
    else {         
        color = "blue";     
    } 
} 
 
changeColor(); 
 
alert("Color is now " + color); 
```
```
var color = "blue"; 
 
function changeColor(){     
   var anotherColor = "red"; 
    function swapColors(){         
      var tempColor = anotherColor;         
      anotherColor = color;         
      color = tempColor; // 这里可以访问 color、anotherColor 和 tempColor     
      } // 这里可以访问 color 和 anotherColor，但不能访问 tempColor             
    swapColors(); 
    } 
 
// 这里只能访问 color changeColor();
```
以上代码共涉及 3 个执行环境：全局环境、changeColor()的局部环境和 swapColors()的局部 环境。全局环境中有一个变量 color 和一个函数 changeColor()。changeColor()的局部环境中有 一个名为 anotherColor 的变量和一个名为 swapColors()的函数，但它也可以访问全局环境中的变 量 color。swapColors()的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。 无论全局环境还是 changeColor()的局部环境都无权访问 tempColor。然而，在 swapColors()内部 则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境

### 4.2.1 延长作用域链

- try-catch 语句的catch块;
- with语句

  这两个语句都会在作用域的前端添加一个变量对象。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
```
function buildUrl() {     
     
     var qs = "?debug=true"; 
     
     with(location){         
        
        var url = href + qs;             
      
      } 
 
    return url; }
```
在此，with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属 性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量 qs。当在 with 语句中引用变量 href 时（实际引用的是 location.href），可以在当前执行环境的变量对象中 找到。当引用变量 qs 时，引用的则是在 buildUrl()中定义的那个变量，而该变量位于函数环境的变 量对象中。至于 with 语句内部，则定义了一个名为 url 的变量，因而 url 就成了函数执行环境的一 部分，所以可以作为函数的值被返回。 

### JavaScript中 with的用法
说起js中的with关键字，很多小伙伴们的第一印象可能就是with关键字的作用在于改变作用域，然后最关键的一点是不推荐使用with关键字。听到不推荐with关键字后，我们很多人都会忽略掉with关键字，认为不要去管它用它就可以了。但是有时候，我们在看一些代码或者面试题的时候，其中会有with关键字的相关问题，很多坑是你没接触过的，所以还是有必要说说with这一个关键字。 


with的基本用法

with 语句的原本用意是为逐级的对象访问提供命名空间式的速写方式. 也就是在指定的代码区域, 直接通过节点名称调用对象。 

with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 


比如，目前现在有一个这样的对象：
```
var obj = {
    a: 1,
    b: 2,
    c: 3
};
```

而用了 with 的写法，会有一个简单的快捷方式
```
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}

```
  在这段代码中，使用了 with 语句关联了 obj 对象，这就以为着在 with 代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性。

with的弊端
  
  在上面的例子中，我们可以看到，with 可以很好地帮助我们简化代码。但是为什么不推荐使用呢？下面我们来说说with的缺点：

#### 导致数据泄漏
我们来看下面的这部分代码
```
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3
};

var o2 = {
    b: 3
}

foo(o1);
console.log(o1.a);  //2

foo(o2);
console.log(o2.a);  //underfined
console.log(a);     //不好，a被泄漏到全局作用域上了
```
  首先，我们来分析上面的代码。例子中创建了 o1 和 o2 两个对象。其中一个有 a 属性，另外一个没有。foo(obj) 函数接受一个 obj 的形参，该参数是一个对象引
  
  用，并对该对象医用执行了 with(obj) {...}。在 with 块内部，对 a 有一个词法引用，实际上是一个 LHS引用，将 2 赋值给了它。 
  
  当我们将 o1 传递进去，a = 2 赋值操作找到了 o1.a 并将 2 赋值给它。而当 o2 传递进去，o2 并没有 a 的属性，因此不会创建这个属性，o2.a 保持undefined。



  但为什么对 o2的操作会导致数据的泄漏呢？ 
  
  这里需要回到对 LHS查询 的机制问题（详情可移步 JavaScript中的LHS和RHS查询）。 
  当我们传递 o2 给 with 时，with 所声明的作用域是 o2, 从这个作用域开始对 a 进行 LHS查询。o2 的作用域、foo(…) 的作用域和全局作用域中都没有找到标识符 a，因此在非严格模式下，会自动在全局作用域创建一个全局变量），在严格模式下，会抛出ReferenceError 异常。

#### 性能下降

在处理相同逻辑的代码中，没用with的运行时间仅为4.63ms，而用with的运行时间长达81.87ms。

这是为什么呢？
>>  原因是JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
>>  但如果引擎在代码中发现了with它只能简单地假设关于标识符为止的判断都是无效的。因为无法知道传递给with用来创建新词法作用域的对象的内容到底是什么。
>>  最悲观的情况是如果出现了with，所有的优化都可能是无意义的。因此引擎会采取最简单的做饭就是完全不做任何优化。如果代码大量使用with或者eval()，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围，也无法避免如果没有这些优化，代码会运行得更慢的事实。
