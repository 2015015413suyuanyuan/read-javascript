## 检测类型

### typeof操作符  instanceof操作符

**typeof操作符：确定一个变量是字符串、数值、布尔值还是undefined**的最佳工具。

**如果变量的值是一个对象或null**，则typeof操作符会返回“**object**”。

**instanceof操作符：判断某个值是什么类型的对象。**

其语法如下所示：
>>  result = variable instanceof constructor



### JavaScript中 with的用法
说起js中的with关键字，很多小伙伴们的第一印象可能就是with关键字的作用在于改变作用域，然后最关键的一点是不推荐使用with关键字。听到不推荐with关键字后，我们很多人都会忽略掉with关键字，认为不要去管它用它就可以了。但是有时候，我们在看一些代码或者面试题的时候，其中会有with关键字的相关问题，很多坑是你没接触过的，所以还是有必要说说with这一个关键字。 


with的基本用法

with 语句的原本用意是为逐级的对象访问提供命名空间式的速写方式. 也就是在指定的代码区域, 直接通过节点名称调用对象。 

with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 


比如，目前现在有一个这样的对象：
```
var obj = {
    a: 1,
    b: 2,
    c: 3
};
```

而用了 with 的写法，会有一个简单的快捷方式
```
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}

```
  在这段代码中，使用了 with 语句关联了 obj 对象，这就以为着在 with 代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性。

with的弊端
  在上面的例子中，我们可以看到，with 可以很好地帮助我们简化代码。但是为什么不推荐使用呢？下面我们来说说with的缺点：

导致数据泄漏
我们来看下面的这部分代码
```
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3
};

var o2 = {
    b: 3
}

foo(o1);
console.log(o1.a);  //2

foo(o2);
console.log(o2.a);  //underfined
console.log(a);     //不好，a被泄漏到全局作用域上了
```
  首先，我们来分析上面的代码。例子中创建了 o1 和 o2 两个对象。其中一个有 a 属性，另外一个没有。foo(obj) 函数接受一个 obj 的形参，该参数是一个对象引
  
  用，并对该对象医用执行了 with(obj) {...}。在 with 块内部，对 a 有一个词法引用，实际上是一个 LHS引用，将 2 赋值给了它。 
  
  当我们将 o1 传递进去，a = 2 赋值操作找到了 o1.a 并将 2 赋值给它。而当 o2 传递进去，o2 并没有 a 的属性，因此不会创建这个属性，o2.a 保持undefined。



  但为什么对 o2的操作会导致数据的泄漏呢？ 
  
  这里需要回到对 LHS查询 的机制问题（详情可移步 JavaScript中的LHS和RHS查询）。 
  当我们传递 o2 给 with 时，with 所声明的作用域是 o2, 从这个作用域开始对 a 进行 LHS查询。o2 的作用域、foo(…) 的作用域和全局作用域中都没有找到标识符 a，因此在非严格模式下，会自动在全局作用域创建一个全局变量），在严格模式下，会抛出ReferenceError 异常。
