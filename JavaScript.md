## 检测类型

### typeof操作符  instanceof操作符

**typeof操作符：确定一个变量是字符串、数值、布尔值还是undefined**的最佳工具。

**如果变量的值是一个对象或null**，则typeof操作符会返回“**object**”。

**instanceof操作符：判断某个值是什么类型的对象。**

其语法如下所示：
>>  result = variable instanceof constructor

### 4.2 执行环境及作用域 
**执行环境**（execution context，为简单起见，有时也称为“环境”）是 JavaScript中最为重要的一个概 念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个 与之关联的**变量对象**（variable object），环境中定义的所有**变量和函数**都保存在这个对象中。

虽然我们 编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 **全局执行环境**是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环 境的对象也不一样。在 Web 浏览器中，**全局执行环境被认为是 window 对象**，因 此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁）。 

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个**环境栈**中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流 正是由这个方便的机制控制着。 

当代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对 象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中 的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。 请看下面的示例代码： 
 ```
var color = "blue"; 
 
function changeColor(){     
if (color === "blue")
    {    
        color = "red";     
    } 
    else {         
        color = "blue";     
    } 
} 
 
changeColor(); 
 
alert("Color is now " + color); 
```
```
var color = "blue"; 
 
function changeColor(){     
   var anotherColor = "red"; 
    function swapColors(){         
      var tempColor = anotherColor;         
      anotherColor = color;         
      color = tempColor; // 这里可以访问 color、anotherColor 和 tempColor     
      } // 这里可以访问 color 和 anotherColor，但不能访问 tempColor             
    swapColors(); 
    } 
 
// 这里只能访问 color changeColor();
```
以上代码共涉及 3 个执行环境：全局环境、changeColor()的局部环境和 swapColors()的局部 环境。全局环境中有一个变量 color 和一个函数 changeColor()。changeColor()的局部环境中有 一个名为 anotherColor 的变量和一个名为 swapColors()的函数，但它也可以访问全局环境中的变 量 color。swapColors()的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。 无论全局环境还是 changeColor()的局部环境都无权访问 tempColor。然而，在 swapColors()内部 则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境

### 4.2.1 延长作用域链

- try-catch 语句的catch块;
- with语句

  这两个语句都会在作用域的前端添加一个变量对象。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
```
function buildUrl() {     
     
     var qs = "?debug=true"; 
     
     with(location){         
        
        var url = href + qs;             
      
      } 
 
    return url; }
```
在此，with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属 性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量 qs。当在 with 语句中引用变量 href 时（实际引用的是 location.href），可以在当前执行环境的变量对象中 找到。当引用变量 qs 时，引用的则是在 buildUrl()中定义的那个变量，而该变量位于函数环境的变 量对象中。至于 with 语句内部，则定义了一个名为 url 的变量，因而 url 就成了函数执行环境的一 部分，所以可以作为函数的值被返回。 

### JavaScript中 with的用法
说起js中的with关键字，很多小伙伴们的第一印象可能就是with关键字的作用在于改变作用域，然后最关键的一点是不推荐使用with关键字。听到不推荐with关键字后，我们很多人都会忽略掉with关键字，认为不要去管它用它就可以了。但是有时候，我们在看一些代码或者面试题的时候，其中会有with关键字的相关问题，很多坑是你没接触过的，所以还是有必要说说with这一个关键字。 


with的基本用法

with 语句的原本用意是为逐级的对象访问提供命名空间式的速写方式. 也就是在指定的代码区域, 直接通过节点名称调用对象。 

with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 


比如，目前现在有一个这样的对象：
```
var obj = {
    a: 1,
    b: 2,
    c: 3
};
```

而用了 with 的写法，会有一个简单的快捷方式
```
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}

```
  在这段代码中，使用了 with 语句关联了 obj 对象，这就以为着在 with 代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性。

with的弊端
  
  在上面的例子中，我们可以看到，with 可以很好地帮助我们简化代码。但是为什么不推荐使用呢？下面我们来说说with的缺点：

#### 导致数据泄漏
我们来看下面的这部分代码
```
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3
};

var o2 = {
    b: 3
}

foo(o1);
console.log(o1.a);  //2

foo(o2);
console.log(o2.a);  //underfined
console.log(a);     //不好，a被泄漏到全局作用域上了
```
  首先，我们来分析上面的代码。例子中创建了 o1 和 o2 两个对象。其中一个有 a 属性，另外一个没有。foo(obj) 函数接受一个 obj 的形参，该参数是一个对象引
  
  用，并对该对象医用执行了 with(obj) {...}。在 with 块内部，对 a 有一个词法引用，实际上是一个 LHS引用，将 2 赋值给了它。 
  
  当我们将 o1 传递进去，a = 2 赋值操作找到了 o1.a 并将 2 赋值给它。而当 o2 传递进去，o2 并没有 a 的属性，因此不会创建这个属性，o2.a 保持undefined。



  但为什么对 o2的操作会导致数据的泄漏呢？ 
  
  这里需要回到对 LHS查询 的机制问题（详情可移步 JavaScript中的LHS和RHS查询）。 
  当我们传递 o2 给 with 时，with 所声明的作用域是 o2, 从这个作用域开始对 a 进行 LHS查询。o2 的作用域、foo(…) 的作用域和全局作用域中都没有找到标识符 a，因此在非严格模式下，会自动在全局作用域创建一个全局变量），在严格模式下，会抛出ReferenceError 异常。

#### 性能下降

在处理相同逻辑的代码中，没用with的运行时间仅为4.63ms，而用with的运行时间长达81.87ms。

这是为什么呢？
>>  原因是JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
>>  但如果引擎在代码中发现了with它只能简单地假设关于标识符为止的判断都是无效的。因为无法知道传递给with用来创建新词法作用域的对象的内容到底是什么。
>>  最悲观的情况是如果出现了with，所有的优化都可能是无意义的。因此引擎会采取最简单的做饭就是完全不做任何优化。如果代码大量使用with或者eval()，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围，也无法避免如果没有这些优化，代码会运行得更慢的事实。

### 4.2.2 没有块级作用域

1.声明变量

使用var声明的变量会自动添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。如下所示：

```
function add(num1, num2){
    var sum = num1 + num2;
    return sum;
}

var result = add(10,20); //30
alert(sum);   //由于sum不是有效的变量，因此会导致错误。
```

以上代码中的函数 add()定义了一个名为 sum 的局部变量，该变量包含加法操作的结果。虽然结 果值从函数中返回了，但变量 sum 在函数外部是访问不到的。如果省略这个例子中的 var 关键字，那 么当 add()执行完毕后，sum 也将可以访问到：

```
function add(num1, num2) {
    sum = num1 + num2;     
    return sum; 
} 
var result = add(10, 20);  //30 
alert(sum);       //30 
```

这个例子中的变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完 add()之后，添 加到全局环境中的变量 sum 将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。 

### 4.3 垃圾收集

JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的手机时间），周期性地执行这一操作。

#### 4.3.1 标记清除

JavaScript中最常用的垃圾收集方式是标记清除。如何标记变量其实并不重要，关键在于采取什么策略。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量已经被环境中的变量引用的变量的标记。而在此之后，再被加上标记的变量将视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占的内存空间。

#### 4.3.2 引用计数

#### 4.3.3 性能问题

垃圾收集器是周期性运行得，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集时间间隔是一个非常重要的问题。
，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行 中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个 做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在 它们离开执行环境时自动被解除引用。

不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离 执行环境，以便垃圾收集器下次运行时将其回收。

4.4 小结
- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值得副本；
- 引用类型的值是对象，保存在堆内存中；
- 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。

### 引用类型
**Object**

一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过， 在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性 以字符串的形式放在方括号中，如下面的例子所示。 
 
 alert(person["name"]);       //"Nicholas" 
 alert(person.name);         //"Nicholas" 
 从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量 来访问属性，例如：
 
 person["first name"] = "Nicholas"; 
 
 
 #### 5.2.2 转换方法
    所有对象都具有 toLocaleString()、toString()和 valueOf()方法。其中，调用 数组的 toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而 调用 valueOf()返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的 toString()方 法。
 
 在这里，我们首先显式地调用了 toString()方法，以便返回数组的字符串表示，每个值的字符串 表示拼接成了一个字符串，中间以逗号分隔。接着调用 valueOf()方法，而后一行代码直接将数组 传递给了 alert()。由于 alert()要接收字符串参数，所以它会在后台调用 toString()方法，由此 会得到与直接调用 toString()方法相同的结果。 
 
 另外，toLocaleString()方法经常也会返回与 toString()和 valueOf()方法相同的值，但也 不总是如此。当调用数组的 toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符 串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 toLocale- String()方法，而不是 toString()方法
 
 #### 5.2.3 栈方法
 
 push():接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度
 pop()：从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。
 
 #### 5.2.4 队列方法
 
 shift()：移除数组中的第一个项并返回该项，同时将数组长度减1。
 unshitf():在数组前端添加任意个项并返回新数组的长度。
 
 #### 5.2.5 重排列方法
 
 reverse()和sort()
 
 reverse()：反转数组项的顺序
 
 sort()方法：（不准确，一般比较的话都是自己写函数）
 
 按升序排列数组项-----即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString(0转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。
 
 sort()方法不填参数的时候，默认是按照字符编码的顺序进行排列的，也就是按照字母的顺序。但是同个大小写的字母字符编码不是连在一起的，0-9在前面，排完之后是A-z，之后才到a-z。
 
 出现开头字母相同的时候，则这些元素排序会根据第二位字母的字符编码进行排序（例如a,aa,ab,ac）以此类推
 
 当然，上面提到的，是没有填写参数的情况下。sort()方法是可以填写参数的，参数规定排序顺序。必须是函数。
 
 ```
 function compare(value1,value2){
  if(value1 <value2){
   return -1;
  }
  else if (value1 >value2){
   return 1;
  }
  else {
   return 0;
  }
 }
 
 var vaules = [0,1,5,10,15];
 values.sort(compare);
 alert(values);
 
 ```
