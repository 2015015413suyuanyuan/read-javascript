## 检测类型

### typeof操作符  instanceof操作符

**typeof操作符：确定一个变量是字符串、数值、布尔值还是undefined**的最佳工具。

**如果变量的值是一个对象或null**，则typeof操作符会返回“**object**”。

**instanceof操作符：判断某个值是什么类型的对象。**

其语法如下所示：
>>  result = variable instanceof constructor

### 4.2 执行环境及作用域 
**执行环境**（execution context，为简单起见，有时也称为“环境”）是 JavaScript中最为重要的一个概 念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个 与之关联的**变量对象**（variable object），环境中定义的所有**变量和函数**都保存在这个对象中。

虽然我们 编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 **全局执行环境**是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环 境的对象也不一样。在 Web 浏览器中，**全局执行环境被认为是 window 对象**，因 此所有全局变量和函数都是作为 window 对象的属性和方法创建的。某个执行环境中的所有代码执行完 毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁）。 

每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个**环境栈**中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流 正是由这个方便的机制控制着。 

当代码在一个环境中执行时，会创建变量对象的一个**作用域链**（scope chain）。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对 象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中 的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始， 然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。 请看下面的示例代码： 
 ```
var color = "blue"; 
 
function changeColor(){     
if (color === "blue")
    {    
        color = "red";     
    } 
    else {         
        color = "blue";     
    } 
} 
 
changeColor(); 
 
alert("Color is now " + color); 
```
```
var color = "blue"; 
 
function changeColor(){     
   var anotherColor = "red"; 
    function swapColors(){         
      var tempColor = anotherColor;         
      anotherColor = color;         
      color = tempColor; // 这里可以访问 color、anotherColor 和 tempColor     
      } // 这里可以访问 color 和 anotherColor，但不能访问 tempColor             
    swapColors(); 
    } 
 
// 这里只能访问 color changeColor();
```
以上代码共涉及 3 个执行环境：全局环境、changeColor()的局部环境和 swapColors()的局部 环境。全局环境中有一个变量 color 和一个函数 changeColor()。changeColor()的局部环境中有 一个名为 anotherColor 的变量和一个名为 swapColors()的函数，但它也可以访问全局环境中的变 量 color。swapColors()的局部环境中有一个变量 tempColor，该变量只能在这个环境中访问到。 无论全局环境还是 changeColor()的局部环境都无权访问 tempColor。然而，在 swapColors()内部 则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境

### 4.2.1 延长作用域链

- try-catch 语句的catch块;
- with语句

  这两个语句都会在作用域的前端添加一个变量对象。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
```
function buildUrl() {     
     
     var qs = "?debug=true"; 
     
     with(location){         
        
        var url = href + qs;             
      
      } 
 
    return url; }
```
在此，with 语句接收的是 location 对象，因此其变量对象中就包含了 location 对象的所有属 性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量 qs。当在 with 语句中引用变量 href 时（实际引用的是 location.href），可以在当前执行环境的变量对象中 找到。当引用变量 qs 时，引用的则是在 buildUrl()中定义的那个变量，而该变量位于函数环境的变 量对象中。至于 with 语句内部，则定义了一个名为 url 的变量，因而 url 就成了函数执行环境的一 部分，所以可以作为函数的值被返回。 

### JavaScript中 with的用法
说起js中的with关键字，很多小伙伴们的第一印象可能就是with关键字的作用在于改变作用域，然后最关键的一点是不推荐使用with关键字。听到不推荐with关键字后，我们很多人都会忽略掉with关键字，认为不要去管它用它就可以了。但是有时候，我们在看一些代码或者面试题的时候，其中会有with关键字的相关问题，很多坑是你没接触过的，所以还是有必要说说with这一个关键字。 


with的基本用法

with 语句的原本用意是为逐级的对象访问提供命名空间式的速写方式. 也就是在指定的代码区域, 直接通过节点名称调用对象。 

with 通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 


比如，目前现在有一个这样的对象：
```
var obj = {
    a: 1,
    b: 2,
    c: 3
};
```

而用了 with 的写法，会有一个简单的快捷方式
```
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}

```
  在这段代码中，使用了 with 语句关联了 obj 对象，这就以为着在 with 代码块内部，每个变量首先被认为是一个局部变量，如果局部变量与 obj 对象的某个属性同名，则这个局部变量会指向 obj 对象属性。

with的弊端
  
  在上面的例子中，我们可以看到，with 可以很好地帮助我们简化代码。但是为什么不推荐使用呢？下面我们来说说with的缺点：

#### 导致数据泄漏
我们来看下面的这部分代码
```
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3
};

var o2 = {
    b: 3
}

foo(o1);
console.log(o1.a);  //2

foo(o2);
console.log(o2.a);  //underfined
console.log(a);     //不好，a被泄漏到全局作用域上了
```
  首先，我们来分析上面的代码。例子中创建了 o1 和 o2 两个对象。其中一个有 a 属性，另外一个没有。foo(obj) 函数接受一个 obj 的形参，该参数是一个对象引
  
  用，并对该对象医用执行了 with(obj) {...}。在 with 块内部，对 a 有一个词法引用，实际上是一个 LHS引用，将 2 赋值给了它。 
  
  当我们将 o1 传递进去，a = 2 赋值操作找到了 o1.a 并将 2 赋值给它。而当 o2 传递进去，o2 并没有 a 的属性，因此不会创建这个属性，o2.a 保持undefined。



  但为什么对 o2的操作会导致数据的泄漏呢？ 
  
  这里需要回到对 LHS查询 的机制问题（详情可移步 JavaScript中的LHS和RHS查询）。 
  当我们传递 o2 给 with 时，with 所声明的作用域是 o2, 从这个作用域开始对 a 进行 LHS查询。o2 的作用域、foo(…) 的作用域和全局作用域中都没有找到标识符 a，因此在非严格模式下，会自动在全局作用域创建一个全局变量），在严格模式下，会抛出ReferenceError 异常。

#### 性能下降

在处理相同逻辑的代码中，没用with的运行时间仅为4.63ms，而用with的运行时间长达81.87ms。

这是为什么呢？
>>  原因是JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
>>  但如果引擎在代码中发现了with它只能简单地假设关于标识符为止的判断都是无效的。因为无法知道传递给with用来创建新词法作用域的对象的内容到底是什么。
>>  最悲观的情况是如果出现了with，所有的优化都可能是无意义的。因此引擎会采取最简单的做饭就是完全不做任何优化。如果代码大量使用with或者eval()，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围，也无法避免如果没有这些优化，代码会运行得更慢的事实。

### 4.2.2 没有块级作用域

1.声明变量

使用var声明的变量会自动添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。如下所示：

```
function add(num1, num2){
    var sum = num1 + num2;
    return sum;
}

var result = add(10,20); //30
alert(sum);   //由于sum不是有效的变量，因此会导致错误。
```

以上代码中的函数 add()定义了一个名为 sum 的局部变量，该变量包含加法操作的结果。虽然结 果值从函数中返回了，但变量 sum 在函数外部是访问不到的。如果省略这个例子中的 var 关键字，那 么当 add()执行完毕后，sum 也将可以访问到：

```
function add(num1, num2) {
    sum = num1 + num2;     
    return sum; 
} 
var result = add(10, 20);  //30 
alert(sum);       //30 
```

这个例子中的变量 sum 在被初始化赋值时没有使用 var 关键字。于是，当调用完 add()之后，添 加到全局环境中的变量 sum 将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。 

### 4.3 垃圾收集

JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的手机时间），周期性地执行这一操作。

#### 4.3.1 标记清除

JavaScript中最常用的垃圾收集方式是标记清除。如何标记变量其实并不重要，关键在于采取什么策略。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量已经被环境中的变量引用的变量的标记。而在此之后，再被加上标记的变量将视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占的内存空间。

#### 4.3.2 引用计数

#### 4.3.3 性能问题

垃圾收集器是周期性运行得，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集时间间隔是一个非常重要的问题。
，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行 中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个 做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在 它们离开执行环境时自动被解除引用。

不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离 执行环境，以便垃圾收集器下次运行时将其回收。

4.4 小结
- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值得副本；
- 引用类型的值是对象，保存在堆内存中；
- 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。
